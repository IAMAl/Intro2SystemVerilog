## 1.モジュール

論理回路は例えば加算回路や制御回路といった目的に沿ったなんらかの機能単位で構成されています。
この構成単位を**モジュール**と呼びます。

例えば加算回路では、全加算回路を複数接続して一つの整数加算回路を構成するように全加算回路を一つのモジュールとして構成しますが、その全加算回路モジュールを複数接続して整数加算回路というモジュールを構成することが想像できると思います。
このようにモジュールがモジュールを包含する記述を行うことで複数の回路で構成された一つの回路を記述します。
これはソフトウェア開発言語での関数と同じ*コンセプト*です。

回路はソフトウェアと違い実際に物理的に構成されるものなので関数呼び出しではなく、モジュールをオブジェクト指向プログラミング言語で例えるとインスタンスとして利用します。
インスタンスを記述し、そのインスタンスに名前をを与えてオブジェクトとして使用し、そのオブジェクトのポートを結線して使用し、そのように記述します。

インスタンス名が```instance_name```のモジュールの記述は

```verilog
module instance_name ( ... );
...
endmodule
```

という形式で**module**と**endmodule**内に回路を記述します。
このモジュールをインスタンスとして```object_name```という名前で使用する際は例えば次のように記述します。

```verilog
instance_name object_name (
...
);

```

モジュール（インスタンス）を記述したとしてそれを利用する際は結線を必要とします。
そのインターフェイスとなる**ポート**を定義することで可能にします。
ポートとはそのモジュールの入出力部分であり、複数のビットを持つ、つまり入出力が幅を持つ場合もあります。
先の例のインスタンス名がinstance_nameの記述にポート記述を追加すると例えばポート宣言は

```verilog
module instance_name (
    input   a,
    input   b,
    input   ci,
    output  d,
    output  co
);
...
endmodule
```

のように記述します。
**input**はこのモジュールへの入力、**output**はこのモジュールからの出力を示す宣言子です。
1ビット幅の場合は幅指定を省略できます。
この例では入力として1ビット幅の**a**、**b**、**ci**という入力ポート、**d**と**co**という1ビット幅の出力ポートを宣言しています。
他に双方向ポートは**inout**で宣言します。
ポートを列挙する際は","で区切ります。

このモジュールを使用する際は例えば


```verilog
instance_name object_name (
    .a(     w_a     ),
    .b(     w_b     ),
    .ci(    w_ci    ),
    .d(     w_d     ),
    .co(    w_co    )
);
...
endmodule
```

と記述します。
``.a(     w_a     )``ではポート**a**について他のところで宣言されたオブジェクト**w_a**を使用して結線しています。
``コンマ+ポート名+(+結線用オブジェクト+)``で記述します。
また列挙する際は","で区切ります。

ポート宣言は他の方法もありますが、この宣言の仕方を使用すればインスタンスとして使用する際にポートの順番をモジュール記述の際のポート宣言順番を守らなくても良くなります。
例えば、先のモジュール記述に対して

```verilog
instance_name object_name (
    .d(     w_d     ),
    .a(     w_a     ),
    .ci(    w_ci    ),
    .b(     w_b     ),
    .co(    w_co    )
);
...
endmodule
```

とオブジェクトを記述しても問題ないです。

ここまでの内容で全加算回路をモジュールとして例えば

```verilog
module full_adder (
    input   a,  // source a
    input   b,  // source b
    input   ci, // carry-in
    output  d,  // output c
    output  co  // carry-out
);
    /* Sum                      */
    assign d    = a ^ b ^ ci;

    /* Carry-Out                */
    assign co   = ( a & b & ~ci ) | ( ~a & b & ci ) | ( a & ~b & ci );

endmodule
```

と記述できます。
コメントは他の言語同様に``/*``と``*/``で挟んだり``//``で記述できます。

このシリーズでは、*こう記述すべき*といったマナー講師のような説明はしませんので、チームメンバー内でコーディングスタイルを決めてそれに従ってください。