## always文とfor文

### always_ff文

これまで値を割り当てる際に”="を使用して代入していました。この代入を**ブロッキング代入**と呼びます。ブロッキング代入は記述上時間の概念がなく信号の伝播を記述したいときに使用します。したがって一般に組み合わせ回路を記述する際にassignと併せて使用します。

レジスタのようなクロックをタイミングとして代入したい場合は**ノンブロッキング代入**”<="を用います。

例えばクロック"clock"を代入タイミング（イベント）としてオブジェクトr_regに代入する場合、
```systemverilog
always_ff @( posedge clock ) begin
    r_reg <= in_a;
end
```
として記述します。この例ではオブジェクトclockの立ち上がり(posedge)をイベントとしてオブジェクトin_aの値を代入しています。”always_ff"は論理合成時にフリップフロップとして扱われることを指示しており@()の中にイベントの対象となるオブジェクト名を記述して明示します。オブジェクト名は複数記述することができ、","で区切りリストにします。また、リストにワイルドカード”*"を使用することができ、この場合は参照されるオブジェクトの値が変化した時をイベントとすることになります。信号の立ち下がりを指定する場合は”negedge"を使用します。さらに立ち上がりや立ち下がりといった信号のエッジではなく信号の入力自体をイベント、つまりレベルをイベントとしたい場合はオブジェクト名を記述するだけです。

またブロッキング代入を使用して

```systemverilog
always_ff @( posedge clock ) begin
    r_reg0 = in_a;
    r_reg1 = r_reg0;
end
```

の様に記述すると上の行から下の行へ代入が行われていることを暗黙の前提にしているので注意してください。従ってクロックをイベントとしてreg_1にはin_aの値が代入され、その経路はin_a→r_reg0→r_reg1となります。

配線や組合せ回路上、閉路の記述はSystemVerilogではサポートされていませんし、論理合成時にワーニング或いはエラーとなります。この閉路、特に組合せ回路上に内在する閉路を**組合せループ**と呼び、論理合成時にこのループを解決する必要があります。大抵の場合、ループは設計上の誤りであり、タイミングについての検討が甘い時或いは回路自体の振る舞いレベルでの設計が誤りの時に発生しやすいです。例えばクロックに同期するオブジェクト(例えばレジスタ)を途中に挟むようにタイミングを調整すれば解決できます。

### always_comb文

組合せ回路を効率よく記述したい場合、**always_comb**を利用できます。