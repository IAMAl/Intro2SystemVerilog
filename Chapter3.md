## assignと宣言子とユーザ定義

### assign
配線(宣言子：wire)や組合せ回路のロジック(宣言子：logic)を結線したい場合**assign**を用います。

例えば配線```w_a```に値を直接割り当てたい場合は

```verilog
assign 割り当てたいオブジェクトの名前 = 即値或いはオブジェクト名;
```

の形式で割り当て、先の例では

```verilog
assign w_a = '0;
```

と記述します。
**SVでは一つの指示の終端にセミコロン";"を付与することで明示します**。
また、ゼロ値を割り当てる場合```'0```とすれば幅を気にせずゼロ値を割り当てることができます。
これは後で説明する構造体の場合、その構造体オブジェクト全体に対して値を割り当てます。

コーディングしている際に一部の部分だけに割り当てたい場合もあるでしょう。
その時は例えば

```verilog
assign w_a[3:1] = '0;
```

としてスライシングを使用して割り当てることができます。
スライシングは特定のビットフィールド範囲を指定する場合に使用します。
この例ではw_aの2ビット目から4ビット目までのはにを指定しています。
スライシングに使用できるのは整数ですが、ローカルパラメータやパラメータで記述することもできます。


注意したいのは論理合成する際に割り当てていない部分は浮遊しておりハイインピーダンスとして扱われます。
ですので、その部分を参照すると組合せ回路では不定として扱われてそれが後続のロジックへ伝播していきます。
assignはあくまで右辺の一部あるいは全ての値を左辺の一部あるいは全てに割り当てるもので、後で説明する代入とは異なります。

また、オブジェクトの全体或いは一部に多重に割り当てている場合(**マルチドライブ**と呼びます)、複数の信号が流入してくるので動作時に不定になる場合が一般なので注意してください。
論理合成時にワーニングとしてレポートされるでしょう。

記述上**logic**宣言と同時に割り当てることができますが、SVはあくまでもハードウェア記述言語でありシミュレーション時にこの記述は値として右辺の値を割り当てます。
従ってシミュレーションの際、右辺の値の変化に伴い不定となることがほとんどなので注意が必要です。

```verilog
wire [3:0] w_wire = '0;
logic [3:0] w_logic = '0;
```

上の例では配線```w_wire```にゼロ値が割り当てられますが、ロジックである```w_logic```ではシミュレーションの際にドライブされるとともに不定となります。

従って

```verilog
logic [3:0] w_logic;
assign w_logic = '0;
```

と記述する必要があります。

これまでポート、配線、ロジックといったオブジェクトを宣言する際にそれぞれ```input```や```output```、```wire```、```logic```といった宣言子を用いました。
これらの宣言子はSVが用意している宣言子であり予約語です。
下の表は代表的な宣言子を示しています。


|宣言子リテラル|意味|
|--------------|----|
| input        | 入力ポート   |
| output       | 出力ポート   |
| inout        | 入出力ポート |
| wire         | ネット       |
| reg          | 回路         |
| logic        | 回路         |


ポート宣言子はあくまでポートを宣言するものでありインスタンスの方を宣言するわけではありません。
従ってポートの宣言時に型を併せて宣言することもあります。

```verilog
input logic [WIDTH-1:0]	i_data
```

このようにポート宣言子の次にインスタンスの型を宣言します。
ポート宣言時に併せて型を宣言することが一般的ですが、チーム内で定めたコーディングスタイルに従いましょう。



開発しているとオブジェクトに構造を持たせたい時がよくあります。
例えば、配線を考える時

```verilog
wire [7:0] w_wire;
assign w_wire[7:5] = ...;
assign w_wire[4] = ...;
assign ... = wire_wire[3:0];
```

と、ビットフィールドに割り当てて記述するのは煩雑になりやすくエラーの温床になります。
また将来ビットフィールドを再定義したい場合にも影響するすべての記述に対して修正が必要になり作業が煩雑になりえます。
例えばこれを

```verilog
assign w_wire.f2 = ...;
assign w_wire.f1 = ...;
assign ... = wire_wire.f0;
```

のように役割に合わせてf2、f1、f0の様に名前を与えて利用できると冗長な書き換え作業を省くことができ、さらにコード本体に触れることが基本ないため、書き換えに伴う誤ったコーディングを防ぐことができます。
SVではこの様なオブジェクトの構造体をユーザーが定義できる特徴を持っています。
この例では

```verilog
typedef wire [2:0]  f2_t;
typedef wire        f1_t;
typedef wire [3:0]  f0_t;
```

のように構造体の内容を**typedef**を用いてwire型として宣言し、使用する際には宣言子として

```systemverilog
f2_t    f2;
```

と一般的な用法で宣言します。
先の例の場合、構造体を作りたいので構造体```w_wire_t```について

```verilog
typedef struct packed {
	f2_t	f2;
	f1_t	f1;
	f0_t    f0;
} w_wire_t;
```

と構造体(```struct```)で複数のオブジェクトを内包する(```packed```)記述で構造体インスタンスを作ることができ、”packed{}”の中に構造体に含めるオブジェクトを宣言しておきます。
これを宣言子として

```verilog
w_wire_t    w_wire;
```

と宣言すればオブジェクト```w_wire```を作成でき、先の様に想定した使用が可能になります。
さらにユーザー定義の宣言子を組み合わせて階層構造のユーザー定義宣言もできます。

```verilog
typedef wire [1:0]      level0_t;
typedef level0_t [3:0]  level1_t;
```

とすれば、```level1_t```の下に```level0_t```の4つの構造を持たせることができます。
そして構造体を階層にもできます。
例えば

```verilog
typedef struct packed {
	w_wire_t    f3;
	logic [7:0]	f1;
	f0_t        f0;
} w_hoge_t;
```

と自由に組み合わせて構造体を作れます。
ただ、構造体を複雑にすると実際使用する際に却って誤りやすくなり、場合によっては検証時に面倒になるかもしれません。
さらに第3者にとってコードが読みにくくもなり、再利用性も下がる可能性がありますので注意が必要です。

以上の様な構造体は複数のモジュールで共用することが想定され、モジュールの中で宣言するのではなく例えば共用のファイルとして別途用意します。
このファイルを**パッケージ**と呼び次の様な宣言の中に記述します。


```verilog
package foo_pkg;

endpackage
```

この例ではパッケージ```foo_pkg```を記述しており、この中に構造体を記述します。
このパッケージを利用したい時は

```verilog
module bar
	import foo_pkg::w_hoge_t;
(ポート宣言);
...
endmodule
```

の様にしてパッケージ```foo_pkg```内で用意されている構造体```w_hoge_t```をモジュール```bar```で参照できる様にします。
また特定の構造体ではなくパッケージ内の全てをとりあえず参照したい場合はワイルドカード```*```で構造体を指定します。
さらに、同じ用法でパッケージ内で別のパッケージを参照することもできます。